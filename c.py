import scanner


class CDefine:
    def __init__(self, name):
        self.name = name

    def __enter__(self):
        print(f"#ifndef {self.name.screaming()}")
        print(f"#define {self.name.screaming()}")
        print()

    def __exit__(self, exc_type, exc_value, exc_tb):
        if exc_type == None:
            print()
            print(f"#endif /* {self.name.snake()} */")


def print_comment_block(text, indent=""):
    print(indent + "/**")
    print(indent + " * " + ("\n" + indent + " * ").join(text.strip().splitlines()))
    print(indent + " */")


def print_short_comment(text, indent=""):
    assert not "\n" in text
    print(indent + "// " + text)


def to_c_type(arg):
    if arg == None:
        return "void"

    if arg.type == "uint":
        return "uint32_t"
    elif arg.type == "int":
        return "int32_t"
    elif arg.type == "fixed":
        return "wl_fixed_t"
    elif arg.type == "string":
        return "const char *"
    elif arg.type == "array":
        return "struct wl_array *"
    elif arg.type == "fd":
        return "int32_t"
    elif arg.type == "object" or arg.type == "new_id":
        if arg.interface:
            return f"struct {arg.interface.snake()} *"
        else:
            return "void *"
    else:
        raise Exception(f"Unknown type {arg.type}")


def to_parameter(arg):
    if is_wl_interface(arg):
        return f"const struct wl_interface * interface, uint32_t version"
    else:
        return f"{to_c_type(arg)} {arg.name.snake()}"


def print_spec_description(spec):
    description = (
        f"The {spec.name.snake()} protocol contains the following interfaces:\n"
    )
    for i in spec.interfaces:
        if i.description.summary:
            description += f"- {i.name.snake()} - {i.description.summary}"
        else:
            description += f"- {i.name.snake()}"
    print_comment_block(description)


def make_header(spec):
    header_name = f"{spec.name.screaming()}_CLIENT_PROTOCOL_H"
    print_comment_block(spec.copyright)
    print()
    print("/* Generated by Universal Wayland Scanner */")
    print()
    print(f"#ifndef {header_name}")
    print(f"#define {header_name}")
    print()
    print("#include <stdint.h>")
    print()
    print("#ifdef __cplusplus")
    print('extern "C" {')
    print("#endif")
    print()
    print()
    print_spec_description(spec)
    print()
    print("typedef int32_t wl_fixed_t;")
    print()


def make_footer(spec):
    print("#ifdef __cplusplus")
    print("}")
    print("#endif")
    print()
    print(f"#endif")


def make_forward_declarations(interfaces):
    for interface in interfaces:
        print(f"struct {interface.name.snake()};")


def make_interface_externs(interfaces):
    for interface in interfaces:
        extern_name = interface.name + "interface"
        print()
        with CDefine(extern_name):
            print()
            if interface.description:
                print_comment_block(interface.description.text)
            print(f"extern const struct wl_interface {extern_name.snake()};")


def make_enums(interface):
    for enum in interface.enums:
        enum_name = interface.name + enum.name
        define_name = enum_name + "enum"
        print()
        with CDefine(enum_name + "enum"):
            if enum.description:
                print_comment_block(enum.description.text)

            print(f"enum {enum_name.snake()} " + "{")

            for entry in enum.entries:
                if entry.summary:
                    print_short_comment(entry.summary, indent="\t")
                name = enum_name + entry.name
                print(f"\t{name.screaming()} = {entry.value},")

            print("};")


def is_wl_interface(arg):
    return arg and arg.is_interface() and arg.interface == None


def get_request_interface(interface, request):
    for a in request.args.args:
        if a and a.is_interface():
            if a.interface:
                return "&" + (a.interface + "interface").snake()
            else:
                return "interface"

    return "NULL"


def get_proxy_marshal_arguments(request):
    arguments = []
    for arg in request.args.marshal_arguments():
        if arg.is_interface():
            if arg.interface == None:
                arguments.append("interface->name")
                arguments.append("version")
            arguments.append("NULL")
        else:
            arguments.append(arg.name.snake())
    return arguments


def make_proxy_marshal(interface, request):
    proxy_arguments = get_proxy_marshal_arguments(request)
    version = (
        "version"
        if "version" in proxy_arguments
        else f"wl_proxy_get_version((struct wl_proxy *){interface.name.snake()})"
    )
    arguments = ", ".join(
        [
            f"(struct wl_proxy *){interface.name.snake()}",
            (interface.name + request.name).screaming(),
            get_request_interface(interface, request),
            version,
            "WL_MARSHAL_FLAG_DESTROY" if request.is_destructor else "0",
            *proxy_arguments,
        ]
    )

    if request.args.return_arg():
        print(
            f"\treturn ({to_c_type(request.args.return_arg())})wl_proxy_marshal_flags({arguments});"
        )
    else:
        print(f"\twl_proxy_marshal_flags({arguments});")


def make_proxy_forward(interface, function_name, return_type, parameters):
    parameters.insert(
        0,
        (
            interface.name.snake(),
            f"struct {interface.name.snake()} *",
            "struct wl_proxy *",
        ),
    )
    parameter_list = [p[1] + " " + p[0] for p in parameters]
    argument_list = [f"({p[2]}) {p[0]}" if len(p) > 2 else p[0] for p in parameters]
    return_stmt = "" if return_type == "void" else "return "

    print()
    print("static inline " + return_type)
    print(
        f"{(interface.name + function_name).snake()}({', '.join(parameter_list)}) "
        + "{"
    )
    print(f"\t{return_stmt}wl_proxy_{function_name}({', '.join(argument_list)});")
    print("}")


def make_requests(interface):
    print()
    for i, request in enumerate(interface.requests):
        request_name = interface.name + request.name
        print(f"#define {request_name.screaming()} {i}")

    for request in interface.requests:
        request_name = interface.name + request.name
        print()
        print(f"static inline {to_c_type(request.args.return_arg())}")
        arg_list = ", ".join(map(to_parameter, request.args.parameters()))
        if len(arg_list) > 0:
            print(
                f"{request_name.snake()}(struct {interface.name.snake()} * {interface.name.snake()}, {arg_list}) "
                + "{"
            )
        else:
            print(
                f"{request_name.snake()}(struct {interface.name.snake()} * {interface.name.snake()}) "
                + "{"
            )

        make_proxy_marshal(interface, request)

        print("}")

    if len(interface.events) > 0:
        make_proxy_forward(interface, "get_user_data", "void *", [])
        make_proxy_forward(interface, "set_user_data", "void", [("data", "void *")])

    make_proxy_forward(interface, "get_version", "uint32_t", [])

    has_destructor = False
    for req in interface.requests:
        if req.is_destructor:
            has_destructor = True

    if not has_destructor:
        make_proxy_forward(interface, "destroy", "void", [])


def make_events(interface):
    if len(interface.events) == 0:
        return

    listener_name = interface.name + "listener"
    print()
    print(f"struct {listener_name.snake()} " + "{")
    for event in interface.events:
        print_comment_block(event.description.text, indent="\t")
        param_list = "".join([f", {to_c_type(a)} {a.name.snake()}" for a in event.args])
        print(
            f"\tvoid (*{event.name.snake()})(void * data, struct {interface.name.snake()} * {interface.name.snake()}{param_list});"
        )
    print("};")

    make_proxy_forward(
        interface,
        "add_listener",
        "int",
        [
            ("listener", f"const struct {listener_name.snake()} *", "void (**)(void)"),
            ("data", "void *"),
        ],
    )


def generate(spec):
    make_header(spec)

    make_forward_declarations(spec.interfaces)

    make_interface_externs(spec.interfaces)

    for interface in spec.interfaces:
        make_enums(interface)
        make_requests(interface)
        make_events(interface)

    make_footer(spec)


def run():
    spec = scanner.parse_stdin()
    generate(spec)


if __name__ == "__main__":
    run()
